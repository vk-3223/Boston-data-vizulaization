# -*- coding: utf-8 -*-
"""Boston_city_data_vizulaization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Io6mFbr3te-_ocFPen936DamNI2YIgD9
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
import numpy as np

pd.options.display.float_format = '{:,.2f}'.format

df_data = pd.read_csv('/content/boston.csv')
df_data

df_data.shape

df_data.head()

df_data.tail()

df_data.isna().values.any()

df_data.duplicated().values.any()

df_data.info()

df_data.describe()

df_data_sort = df_data.sort_values('PRICE',ascending=False)
df_data_sort

df_data.columns

df_data.count()

sns.displot(df_data['PRICE'],bins=50,aspect=2,kde=True,color='#2196f3')
plt.title(f'1970s Home Values in Boston. Average: ${(1000*df_data.PRICE.mean()):.6}')
plt.xlabel('Price in 000s')
plt.ylabel('Nr. of Homes')

plt.show()

sns.displot(df_data.DIS,bins=50,kde=True,color="darkblue")
plt.title(f'Distance to Employment Centres. Average: {(df_data.DIS.mean()):.2}')
plt.xlabel('Weighted Distance to 5 Boston Employment Centres')
plt.ylabel('Nr. of Homes')

plt.show()

sns.displot(df_data.RM,kde=True,aspect=2,color="#00796b")
plt.title(f'Distribution of Rooms in Boston. Average: {df_data.RM.mean():.2}')
plt.xlabel('Average Number of Rooms')
plt.ylabel('Nr. of Homes')

plt.show()

plt.figure(figsize=(10,5),dpi=200)

plt.hist(df_data['RAD'],bins=24,ec='black',color='#7b1fa2',rwidth=0.5)

plt.xlabel('Accessibility to Highways')
plt.ylabel('Nr. of Houses')
plt.show()

river_access = df_data['CHAS'].value_counts()
bar = px.bar(x=['No','Yes'],y=river_access.values,color=river_access.values,color_continuous_scale=px.colors.sequential.haline,
             title='Next to Charles River?')

bar.update_layout(xaxis_title='Property Located Next to the River?', 
                  yaxis_title='Number of Homes',
                  coloraxis_showscale=False)
bar.show()

sns.pairplot(df_data)
plt.show()

with sns.axes_style('darkgrid'):
  sns.jointplot(x=df_data['DIS'],y=df_data['NOX'],height=8,kind='scatter',color='deeppink',joint_kws={'alpha':0.5})

plt.show()

with sns.axes_style('darkgrid'):
  sns.jointplot(x=df_data.NOX,y=df_data.INDUS,height=7,color='darkgreen',joint_kws={'alpha':0.5})

plt.show()

with sns.axes_style('darkgrid'):
  sns.jointplot(x=df_data['LSTAT'],y=df_data['RM'],height=7,color='orange',joint_kws={'alpha':0.5})
plt.show()

plt.figure(figsize=(10,5),dpi=200)
with sns.axes_style('darkgrid'):
  sns.jointplot(x=df_data.LSTAT,y=df_data.PRICE,height=0.7,color='crimson',joint_kws={'alpha':0.5})

plt.show()

with sns.axes_style('whitegrid'):
  sns.jointplot(x=df_data.RM,y=df_data.PRICE,height=7,color='darkblue',joint_kws={'alpha':0.5})
plt.show()

target = df_data['PRICE']
feature = df_data.drop('PRICE',axis=1)
x_tarin,x_test,y_tarin,y_test = train_test_split(feature,target,test_size=0.2,random_state=10)

train_pct = 100*len(x_tarin)/len(feature)
print(f'taraing data is {train_pct:.3} % of total data')

test_pct = 100*x_test.shape[0]/feature.shape[0];
print(f'Test make up the reaming {test_pct:.3} % of total data')

regr = LinearRegression()
regr.fit(x_tarin,y_tarin)

rsquared = regr.score(x_tarin,y_tarin)

print(f'rsquared value is {rsquared:.2}')

regr_coef = pd.DataFrame(data=regr.coef_,index=x_tarin.columns,columns=['Coefficient'])
regr_coef

permium = regr_coef.loc['RM'].values[0]*1000
print(permium)

predicted_values = regr.predict(x_tarin)
residuals = (y_tarin-predicted_values)
residuals

plt.figure(dpi=200)
plt.scatter(x=y_tarin,y=predicted_values,c='indigo',alpha=0.6)
plt.plot(y_tarin,y_tarin,color='cyan')
plt.title(f'Actual vs Predicted Prices: $y _i$ vs $\hat y_i$', fontsize=17)
plt.xlabel('Actual prices 000s $y _i$', fontsize=14)
plt.ylabel('Prediced prices 000s $\hat y _i$', fontsize=14)

plt.show()

plt.figure(dpi=100)
plt.scatter(x=predicted_values,y=residuals,c='indigo',alpha=0.6)
plt.title('Residuals vs Predicted Values', fontsize=17)
plt.xlabel('Predicted Prices $\hat y _i$', fontsize=14)
plt.ylabel('Residuals', fontsize=14)
plt.show()

resid_mean = round(residuals.mean(),2)
resid_skew = round(residuals.skew(),2)

sns.displot(residuals,kde=True,color='indigo')
plt.title(f'Residuals Skew ({resid_skew}) Mean ({resid_mean})')
plt.show()

tgt_skew = df_data['PRICE'].skew()
sns.displot(df_data['PRICE'],kde='kde',color='green')
plt.title(f'Normal Prices. Skew is {tgt_skew:.3}')
plt.show()

y_log = np.log(df_data['PRICE'])
sns.displot(y_log,kde=True)
plt.title(f'Log Prices. Skew is {y_log.skew():.3}')
plt.show()

plt.figure(dpi=150)
plt.scatter(df_data.PRICE,np.log(df_data.PRICE))

plt.title('Mapping the Original Price to a Log Price')
plt.ylabel('Log Price')
plt.xlabel('Actual $ Price in 000s')
plt.show()

new_target = np.log(df_data['PRICE'])
feature = df_data.drop('PRICE',axis=1)

x_train,x_test,log_y_train,log_y_test = train_test_split(feature,new_target,test_size=0.2,random_state=10)

log_regr = LinearRegression()
log_regr.fit(x_train,log_y_train)
log_rsquared = log_regr.score(x_train,log_y_train)

log_predictions = log_regr.predict(x_train)
log_residuals = (log_y_train-log_predictions )

print(f'Training data r-squared: {log_rsquared:.2}')

df_coef = pd.DataFrame(data=log_regr.coef_,index=x_train.columns,columns=['coef'])
df_coef

plt.scatter(x=log_y_train,y=log_predictions,c='navy',alpha=0.6)
plt.plot(log_y_train,log_y_train,color='cyan')
plt.title(f'Actual vs Predicted Log Prices: $y _i$ vs $\hat y_i$ (R-Squared {log_rsquared:.2})', fontsize=17)
plt.xlabel('Actual Log Prices $y _i$', fontsize=14)
plt.ylabel('Prediced Log Prices $\hat y _i$', fontsize=14)
plt.show()

plt.scatter(x=y_tarin,y=predicted_values,c='indigo',alpha=0.6)
plt.plot(y_tarin,y_tarin,color='cyan')
plt.title(f'Original Actual vs Predicted Prices: $y _i$ vs $\hat y_i$ (R-Squared {rsquared:.3})', fontsize=17)
plt.xlabel('Actual prices 000s $y _i$', fontsize=14)
plt.ylabel('Prediced prices 000s $\hat y _i$', fontsize=14)
plt.show()

plt.scatter(x=log_predictions,y=log_residuals,c='navy',alpha=0.6)
plt.title('Residuals vs Fitted Values for Log Prices', fontsize=17)
plt.xlabel('Predicted Log Prices $\hat y _i$', fontsize=14)
plt.ylabel('Residuals', fontsize=14)
plt.show()

plt.scatter(x=predicted_values,y=residuals,c='indigo',alpha=0.6)
plt.title('Original Residuals vs Fitted Values', fontsize=17)
plt.xlabel('Predicted Prices $\hat y _i$', fontsize=14)
plt.ylabel('Residuals', fontsize=14)
plt.show()

log_resid_mean = round(log_residuals.mean(), 2)
log_resid_skew = round(log_residuals.skew(), 2)

sns.displot(log_residuals, kde=True, color='navy')
plt.title(f'Log price model: Residuals Skew ({log_resid_skew}) Mean ({log_resid_mean})')
plt.show()

sns.displot(residuals, kde=True, color='indigo')
plt.title(f'Original model: Residuals Skew ({resid_skew}) Mean ({resid_mean})')
plt.show()

print(regr.score(x_test,y_test))
print(log_regr.score(x_test,log_y_test))

features = df_data.drop(['PRICE'], axis=1)
average_vals = features.mean().values
property_stats = pd.DataFrame(data=average_vals.reshape(1, len(features.columns)), 
                              columns=features.columns)

log_estimate = log_regr.predict(property_stats)[0]
print(f'The log price estimate is ${log_estimate:.3}')

# Convert Log Prices to Acutal Dollar Values
dollar_est = np.e**log_estimate * 1000
# or use
dollar_est = np.exp(log_estimate) * 1000
print(f'The property is estimated to be worth ${dollar_est:.6}')

next_to_river = True
nr_rooms = 8
students_per_classroom = 20 
distance_to_town = 5
pollution = df_data.NOX.quantile(q=0.75) # high
amount_of_poverty =  df_data.LSTAT.quantile(q=0.25) # low

property_stats['RM'] = nr_rooms
property_stats['PTRATIO'] = students_per_classroom
property_stats['DIS'] = distance_to_town

if next_to_river:
    property_stats['CHAS'] = 1
else:
    property_stats['CHAS'] = 0

property_stats['NOX'] = pollution
property_stats['LSTAT'] = amount_of_poverty

log_estimate = log_regr.predict(property_stats)[0]
print(f'The log price estimate is ${log_estimate:.3}')

# Convert Log Prices to Acutal Dollar Values
dollar_est = np.e**log_estimate * 1000
print(f'The property is estimated to be worth ${dollar_est:.6}')